package cs228hw2;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.*;

/**
 * A infinatly presise number that you can add subtract, negate, and take the
 * absolute value of backed by ALL
 * 
 * @author nicholaskrabbenhoft
 *
 */
public class AmusingPreciseNumber {

	private Deque228<Byte> thisNumber;
	private long numOfDecimals;
	private boolean isPositive;

	/**
	 * Constructor that makes the number the value of the given int
	 * 
	 * @param numb int that you want to set the data to
	 */
	public AmusingPreciseNumber(int numb) {

		// Just turn it into a string and use the string creator
		Integer temp = numb;

		try {
			createFromReader(new StringReader(temp.toString()));
		} catch (Exception e) {
		}

	}

	/*
	 * Create an AmusingPreciseNumber from a String. The formatting of the string is
	 * some number of digits with an optional decimal pobyte. Your constructor is
	 * required to throw a runtime exception if the string does not have a valid
	 * syntax. Valid strings do include 0, 0.0, 0000, 00000123, 00000123.000001000,
	 * - 23432, +1234., and +1234555. That is, leading or trailing zeros, a single
	 * leading plus or minus sign, and no plus or minus sign are all valid numbers.
	 * In effect, any reasonable string of digits (no matter how long) that can be
	 * byteerpreted as a number is valid.
	 */
	/**
	 * A constructor that takes a number such as 0, 0.0, 0000, 00000123,
	 * 00000123.000001000, - 23432, +1234., and +1234555 and tranphormes them into a
	 * AmusingPreciseNumber of the same value
	 * 
	 * @param numb The string you want to make a number
	 * @throws Exception if you try to make a number out of non number stuff it'll
	 *                   get made at you. This doesn't take spelled out numbers
	 *                   either
	 */
	public AmusingPreciseNumber(String numb) throws Exception {
		this.createFromReader(new StringReader(numb));

	}

	/*
	 * The same as the string constructor except the input comes from arbitrary
	 * Reader. This means that there is no bound on the number of digits for this
	 * constructor. The format is similar to the String constructor except that a
	 * whitespace character is treated as a termination of the input and no further
	 * data is read from the stream once this whitespace character is read. Leading
	 * whitespace characters are ignored. We will test that this constructor can
	 * handle at least 100,000 digits of precision.
	 */
	/**
	 * Constructor that creates a number out of a reader. The same rules apply as
	 * the string constructor but now there's no length limit
	 * 
	 * @param r The reader containing the info you want to make the number out of
	 * @throws Exception if you try to make a number out of non number stuff it'll
	 *                   get made at you. This doesn't take spelled out numbers
	 *                   either
	 */
	public AmusingPreciseNumber(Reader r) throws Exception {
		createFromReader(r);

	}

	/**
	 * Private methiod that takes the reader given or created in the constructors
	 * that take a reader, string, or int and actually makes the number
	 * 
	 * @param r the reader to make the number out of
	 * @throws Exception an IOException is thrown if the reader has bad data
	 */
	private void createFromReader(Reader r) throws Exception {

		thisNumber = new Deque228<Byte>();

		boolean pastDecimal = false;

		String next = intToString(r.read());

		// This moves past all begining white space
		while (java.lang.Character.isWhitespace(next.charAt(0))) {
			next = intToString(r.read());
		}

		// next = intToString(r.read());

		// This checks if there is a + or - and then sets the sign accordingly
		if (next.charAt(0) == '-') {
			this.isPositive = false;
			next = intToString(r.read());
		} else if (next.charAt(0) == '+') {
			this.isPositive = true;
			next = intToString(r.read());
		} else {
			this.isPositive = true;
		}

		while (true) {

			// if this has more then one decimal or any non numeric chars then it will throw
			// an exception
			// otherwise it puts the valuses on the stack
			if (".".contains(next) && !pastDecimal)
				pastDecimal = true;
			else if ("1234567890".contains(next)) {

				this.thisNumber.offer(Byte.parseByte(next));
				if (pastDecimal) {
					this.numOfDecimals++;
				}

			} else if (java.lang.Character.isWhitespace(next.charAt(0))) {

				break;

			} else {
				throw new IOException();
			}

			next = intToString(r.read());
		}

		// This checks if it doesn't contain 123456789 and then if it doesn't contain 0
		// if it doesn't contain any of them it throughs an error because it needs some
		// value
		if (isZero(this) && !this.thisNumber.contains((byte) 0)) {
			throw new IOException();
		}

		r.close();

	}

	/**
	 * This is a private methiod that takes an int generated by the reader and
	 * changes it to a char or a whitespace if it is done and then turns it into a
	 * string to return
	 * 
	 * @param read an int generated by a reader that can't be a white space
	 * @return a string composed of one char that the reader gave or a whitespace if
	 *         done
	 */
	private String intToString(int read) {

		// if the steam ends the int will be -1 and the program knows to take white
		// space as the end
		if (read == -1) {
			return " ";
		}
		String temp = "" + (char) read;
		return temp;
	}

	/**
	 * Constructor that takes a number and copies it over. Note this is a deep copy
	 */
	public AmusingPreciseNumber(AmusingPreciseNumber temp) {
		this.isPositive = temp.isPositive();
		this.thisNumber = temp.getDeque().clone();
		this.numOfDecimals = temp.getDepth();
	}

	/**
	 * A constructor that takes all of the member variables to set
	 * 
	 * @param deque228 a deque holding the digits in a stack
	 * @param positive a bool saying whether the number is positive
	 * @param depth    the depth of decimals in the number
	 */
	private AmusingPreciseNumber(Deque228<Byte> deque228, boolean positive, long depth) {
		thisNumber = new Deque228<Byte>();
		this.isPositive = positive;
		this.thisNumber = deque228;
		this.numOfDecimals = depth;
	}

	/**
	 * A private methiod that takes a AmusingPreciseNumber and sets this number to
	 * all of it's values essietialy making this a deep copy of it
	 * 
	 * @param temp the AmusingPreciseNumber to make this a clone of
	 */
	private void set(AmusingPreciseNumber temp) {
		this.isPositive = temp.isPositive();
		this.thisNumber = temp.getDeque().clone();
		this.numOfDecimals = temp.getDepth();
	}

	/**
	 * This is a methiod that adds the given number to this number
	 * 
	 * @param numb the number to be added to this one
	 */
	public void add(AmusingPreciseNumber numb) {

		// this sets the object values equal to the results of the add methiod
		set(add(this, numb));

	}

	/**
	 * This is a helper methiod to increase the nubmer of 0 behind the decimble
	 * point of a number
	 * 
	 * @param depth the number of numbers that should be behind the decimble point
	 *              which must be more then current depth
	 */
	private void setDepth(double depth) {

		if (depth < this.numOfDecimals) {
			throw new IndexOutOfBoundsException();
		}

		while (depth > numOfDecimals) {

			thisNumber.offer((byte) 0);
			numOfDecimals++;

		}

	}

	/**
	 * This is a methiod to remove any trailing zero's from the number
	 */
	private void trim() {

		while ((thisNumber.peekLast() == 0 && numOfDecimals > 0)) {

			thisNumber.removeLast();
			numOfDecimals--;

		}

	}

	/**
	 * This is a private methiod designed to make it so both numbers have the same
	 * amount below the decimible point. It will find the one with the greater
	 * number of deciamal points and then add the correct number of trailing zeros
	 * to the one with less decimal places
	 * 
	 * @param numb the number to make comparable to this number
	 */
	private void makeComparible(AmusingPreciseNumber numb) {
		this.trim();
		numb.trim();

		if (this.getDepth() > numb.getDepth()) {
			numb.setDepth(this.getDepth());
		} else {
			this.setDepth(numb.getDepth());
		}

	}

	/**
	 * This methiod subtracts the given number from this number
	 * 
	 * @param numb the number to subtract from this number
	 */
	public void subtract(AmusingPreciseNumber numb) {

		// This sets the values to the results from the subtract methiod
		set(subtract(this, numb));

	}

	/**
	 * Negate this AmusingPreciseNumber
	 */
	public void negate() {
		isPositive = !isPositive;
	}

	/**
	 * Compute and store the absolute value of this AmusingPreciseNumber
	 */
	public void abs() {
		isPositive = true;
	}

	/**
	 * This is a methiod that takes 2 AmusingPreciseNumber and creates another
	 * AmusingPreciseNumber to return that is the sum of the 2 numbers
	 * 
	 * @param input1 the first number to add
	 * @param input2 the secound number to add
	 * @return an AmusingPreciseNumber that is the sum of the 2 inputs
	 */
	public static AmusingPreciseNumber add(AmusingPreciseNumber input1, AmusingPreciseNumber input2) {

		AmusingPreciseNumber numb1 = new AmusingPreciseNumber(input1);
		AmusingPreciseNumber numb2 = new AmusingPreciseNumber(input2);

		// If they are different signs then just toss it over subtract so I only have to
		// deal with the case where they have the same signs
		if (numb1.isPositive != numb2.isPositive) {
			return subtract(numb1, negate(numb2));
		}

		numb1.makeComparible(numb2);

		Deque228<Byte> num1Deque = numb1.getDeque();
		Deque228<Byte> num2Deque = numb2.getDeque();

		Deque228<Byte> answer = new Deque228<Byte>();

		byte carry = 0;

		// This process should work just like elementary addition. Add the two least
		// significant bits and then carry the 1 if it's bigger then 10

		while (!num1Deque.isEmpty() && !num2Deque.isEmpty()) {

			// get the next to values and add them together in temp with the carry from the
			// last thing
			// Note carry should never be more then 1 and the next byte values should never
			// be more then 9
			byte temp = (byte) (num1Deque.removeLast().byteValue() + num2Deque.removeLast().byteValue() + carry);
			// put the least s
			answer.push((byte) ((temp) % 10));

			carry = (byte) (temp / 10);

		}

		// These 2 while loops fill out the rest of the numbers and add the carry if
		// there is one left over
		while (!num1Deque.isEmpty()) {
			byte input = (byte) (num1Deque.removeLast() + carry);
			answer.push((byte) ((input) % 10));
			carry = (byte) ((input) / 10);
		}

		while (!num2Deque.isEmpty()) {
			byte input = (byte) (num2Deque.removeLast() + carry);
			answer.push((byte) ((input) % 10));
			carry = (byte) ((input) / 10);
		}

		if (carry != 0) {
			answer.push(carry);
		}

		// Set the calculated number to the number held by this object

		return new AmusingPreciseNumber(answer, numb1.isPositive(), numb1.getDepth());

	}

	/**
	 * A methiod that creates a readable string from the AmusingPreciseNumber
	 */
	@Override
	public String toString() {

		// There's some iffy stuff that sometimes gives -0 so this deals with that
		if (isZero(this)) {
			return "0";
		}

		String returnString = "";

		Deque228<Byte> destroable = this.thisNumber.clone();

		double depth = destroable.size() - this.numOfDecimals;

		while (depth > 0) {
			returnString += destroable.pop().toString();
			depth--;
		}

		if (!destroable.isEmpty()) {
			returnString += ".";
		}

		while (!destroable.isEmpty()) {
			returnString += destroable.pop().toString();// returnString;
		}

		if (this.isPositive) {
			returnString = "" + returnString;
		} else {
			returnString = "-" + returnString;
		}

		return clean(returnString);

	}

	/**
	 * Private methiod to remove leading and trailing zeros from the to string
	 * methiod
	 * 
	 * @param input the string to remove leading and trailing zeros from
	 * @return a copy of the input but with the leading and trailing zeros removed
	 */
	private String clean(String input) {

		if (input.equals("")) {
			return "";
		}

		int i = 0;
		String returnString = "";
		if (input.charAt(0) == '-') {
			returnString = "-" + returnString;
			i = 1;
		}

		// move past all leading zero's
		for (i = i; i < input.length(); i++) {
			if (input.charAt(i) != '0') {
				break;
			}
		}

		String holding = "";
		while (i < input.length()) {

			while ((i < input.length() - 1 || returnString.contains(".")) && input.charAt(i) == '0') {
				holding += "0";
				i++;
				if (i >= input.length() && returnString.contains(".")) {
					return returnString;
				}
			}

			returnString = returnString + holding + input.charAt(i);

			holding = "";
			i++;
		}

		if (returnString.charAt(returnString.length() - 1) == '.') {
			returnString = returnString.substring(0, returnString.length() - 1);
		}

		return returnString;
	}

	/**
	 * Helper methiod to check if the given number is 0
	 * 
	 * @param n the number to check if it is zer0
	 * @return true if the AmusingPreciseNumber's Deque doesn't cointaian nonzero
	 *         numbers
	 */
	private static boolean isZero(AmusingPreciseNumber n) {

		for (byte i = 1; i < 10; i++) {
			if (n.thisNumber.contains(i)) {
				return false;
			}
		}
		return true;

	}

	/**
	 * Methiod that returns an AmusingPreciseNumber that has the value of the first
	 * input minus the secound input
	 * 
	 * @param input1 the number to be subtracted from
	 * @param input2 the number to subtract
	 * @return an AmusingPreciseNumber that is the difference between the first and
	 *         second input
	 */
	public static AmusingPreciseNumber subtract(AmusingPreciseNumber input1, AmusingPreciseNumber input2) {

		AmusingPreciseNumber numb1 = new AmusingPreciseNumber(input1);
		AmusingPreciseNumber numb2 = new AmusingPreciseNumber(input2);

		// Problems when subtact 0 so make special case

		if (isZero(numb2)) {
			return numb1;
		}

		// If the numbers don't have the same sign just negate one and add them
		if ((numb1.isPositive != numb2.isPositive)) {

			// create a new amusing number that is simply the negated number 2 and add them
			// so they have the same sign
			return add(numb1, negate(numb2));

		}

		boolean isPositive;
		Deque228<Byte> num1Deque;
		Deque228<Byte> num2Deque;

		// This is designed to make sure the numb1Iter iterator is always the iterator
		// for
		// the number with a larger magnitude and if numb1 is greater magnitude we set
		// the answers sign to num1 sign otherwise num1's inverse
		if (numb1.isGreaterMagnitiude(numb2)) {
			isPositive = numb1.isPositive;
			num1Deque = numb1.getDeque();
			num2Deque = numb2.getDeque();

		} else {
			isPositive = !numb1.isPositive;
			num1Deque = numb2.getDeque();
			num2Deque = numb1.getDeque();
		}

		Deque228<Byte> answer = new Deque228<Byte>();

		byte carry = 0;

		// This works just like elementary subtraction. Subtract the least significant
		// bits and borrow one if the subtractor is bigger then the subtrcted. because
		// of previous checks I know the subtractor always has a smaller magnitiude
		while (!num1Deque.isEmpty() && !num2Deque.isEmpty()) {

			// get the next to values and subtract them in temp with the carry from the
			// last thing
			// Note: carry should never be more then 1 and the next byte values should never
			// be more then 9
			byte temp = (byte) (num1Deque.removeLast().byteValue() - (num2Deque.removeLast().byteValue() + carry));

			// if temp is negitive pull a 10 from the next and make carry 1
			if (temp < 0) {
				carry = 1;
				// make temp positive
				temp *= -1;

				answer.push((byte) ((10 - ((temp) % 10)) % 10));
			} else {

				answer.push((byte) ((temp) % 10));
				carry = 0;
			}

		}

		// I know num2 will always run out 1st or at the same time so I don;t have to
		// check it
		// This puts in the rest of num1 and deals with the carry
		while (!num1Deque.isEmpty()) {
			byte temp = (byte) ((num1Deque.removeLast() - carry));

			if (temp < 0) {
				carry = 1;
				// make temp positive
				temp *= -1;

				// temp is negitive to make it positive
				answer.push((byte) (10 - ((temp) % 10)));
			} else {

				answer.push((byte) ((temp) % 10));
				carry = 0;
			}

		}

		// Set the calculated number depth to the number held by this object
		// Note: both numb1 or 2 should work because they should have the same depth

		return new AmusingPreciseNumber(answer, isPositive, numb1.getDepth());

	}

	/**
	 * This is a methiod to determin if the current number has a greater magnitude
	 * then paramiter
	 * 
	 * @param numb2 the number to compare against
	 * @return boolean true if this number is greater then the paramiter
	 */
	/**/private/**/ boolean isGreaterMagnitiude(AmusingPreciseNumber numb) {
		this.makeComparible(numb);

		ListIterator<Byte> thisIter = this.getDeque().listIterator();
		ListIterator<Byte> numIter = numb.getDeque().listIterator();

		// these are just garbage varibles that will never be used if either number has
		// any values in it and if not will say that this is not a greater magnitiude
		// These hold the greatest different significant bit
		byte thisTemp = -1;
		byte numTemp = -1;

		// get to the bottom of the stack to find most significant digit
		while (thisIter.hasNext() && numIter.hasNext()) {

			// store the values of the of the largest differnt digit
			if (thisTemp == numTemp) {
				thisTemp = thisIter.next();
				numTemp = numIter.next();
			} else {

				thisIter.next();
				numIter.next();
			}
		}

		// If either has more that means its bigger
		if (thisIter.hasNext()) {
			return true;
		} else if (numIter.hasNext()) {
			return false;
		}

		// if both have the same number of digits checked the stored greatest differnt
		// digit
		return thisTemp > numTemp;

	}

	/**
	 * Methiod that returns an AmusingPreciseNumber that is the negative of numb and
	 * leave numb unchanged.
	 * 
	 * @param numb the number to be negated
	 * @return an AmusingPreciseNumber that is the negitive of the input
	 */
	public static AmusingPreciseNumber negate(AmusingPreciseNumber numb) {
		return new AmusingPreciseNumber(numb.getDeque(), !numb.isPositive, numb.getDepth());
	}

	/**
	 * A methiod that returns an AmusingPreciseNumber that is the absolute value of
	 * numb
	 * 
	 * @param numb the number to return a copy of in its absolute value form
	 * @return an AmusingPreciseNumber that is the absolute value of the input
	 */
	public static AmusingPreciseNumber abs(AmusingPreciseNumber numb) {
		return new AmusingPreciseNumber(numb.getDeque(), true, numb.getDepth());
	}

	/**
	 * Accesor methiod to get a copy of the numbers deque
	 * 
	 * @return a deep copy of this numbers deque
	 */
	public Deque228<Byte> getDeque() {

		return thisNumber.clone();

	}

	/**
	 * Accesor methiod to check if the number is positive
	 * 
	 * @return true if the number is positive, zero may be positive or negitive
	 */
	public boolean isPositive() {
		return isPositive;
	}

	/**
	 * Accesor to get an iterator for the deque of this Number
	 * 
	 * @return an iterator of the backing deque
	 */
	public Iterator<Byte> iterator() {

		return thisNumber.iterator();
	}

	/**
	 * A methiod to return the number of numbers behind the decimble points
	 * 
	 * @return double which is the number of numbers behind the decimal
	 */
	public long getDepth() {
		return numOfDecimals;
	}

}
